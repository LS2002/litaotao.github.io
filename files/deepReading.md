# 如何读一本书



- ***reason***: what makes you read that book
- ***what***: what does that book tells, the opinion, the methodology, using the catalog
- ***Answering***: Does the book answer your questions
- ***questions:*** Any questions after reading
- ***reviews:*** read and collect some high-quality reviews by others, best reviews and worst reviews



## 1. 2010.10 | 简约至上：交互设计的四原则

- reason
  - 了解，学习，掌握产品设计的思路和方法
  - 觉得使用的一些产品设计上有很多蹩脚的地方，但是不确定是本身设计有问题，还是我个人的使用习惯太奇葩，所以学习一些设计相关的东西来进行验证
  - 为将来创业做打算，在产品设计方便，虽然不必做到精通，但要做到知其然，知其所以然
  - 兴趣，觉得产品设计也是门学问，挺有意思的
- what
  - 讲述了产品设计中 ***简约至上*** 的原则，我一直很赞同这个观点，这也是我读这本书的最大原因之一
  - 从四个方面来讲如何简约化产品：
    - 删除：去掉所有不必要的按钮，直至减到不能再减
    - 组织：按照有意义的标准将按钮分成组
    - 隐藏：把那些不是最重要的按钮安排在隐秘的地方，避免分散用户的注意力
    - 转移：只保留最基本常用的功能，将其他功能转移到屏幕上，从而将功能复杂性进行转移
  - 本书写得特别简介，基本没有废话，原文也是；中文版几乎是在贵阳回上海的高铁上花两小时看完的；英文版也很薄，准备有时间再看看英文版
  - 虽然书薄，但是内容丰富，例子很多，而且配了很多优质插图
- Answering
  - 的确回答了我一些疑问
- questions
  - 从产品设计本身来说，没有什么太大的问题了，但是扩展到创业方面的话，产品设计只是其中一环，在商业模式分析，市场分析，用户分析这些方面还需要加强学习
- reviews
  - 评价都很高，大多都是读书笔记，有推荐其他书：《点石成金》,《启示录》；知乎问题 [哪三本书是产品经理必读书？为什么？](https://www.zhihu.com/question/20752514)， 里面的书也很不错，可以安排时间读一读。
  - 有些很高质量的评价，比如有一个评价讲了 apple 商标的设计：
  - ![](../images/apple.png)
  - ​



## 2. 2010.10 | 乌合之众，大众心理研究

- reason
  - 看到不少人推荐这本书，豆瓣评分也不错
- what
  - 本书讲了个体和群体之间的心理，以及社会的群体心理特征，可以通过目录来看书写脉络
  - 本书在09.30上海飞贵阳的飞机上看完的，不得不说 kindle 是个好东西，哈哈，但是看完后体验不是特别深刻，只觉得在研究消费群体的时候有一些心理行为可以借鉴，但是也不能一下子说出怎么借鉴
  - 核心观点似乎是说群体都是偏 low 的，人才在群体中会渐渐变得平庸，也许也是从另外一个方面来说天才都是孤独的？
  - 第一部分：群体心理
    - 群体的一般特征：如何从心理学上来定义一个群体以及群体的特征
    - 群体的感情和道德观：冲动，易变，急躁，易受暗示，轻信，夸张，单纯，偏执，专横，保守，羊群
    - 群体的观念，推理和想象力：
    - 群体所采取的宗教形式
  - 第二部分：群体的意见与信念
    - 群体的意见和信念中的间接因素：种族，传统，时间，政治和社会制度，教育
    - 群体意见的直接因素：形象，词语和套话，幻觉，经验，理性
    - 群体领袖及其说服的手法：领袖的动员手段有断言，重复和传染
    - 群体的信念和意见的变化范围
  - 第三部分：不同群体的分类及其特点
    - 群体的分类：异质性群体，同质性群体
    - 被称为犯罪群体的群体：
    - 刑事案件的陪审团：
    - 选民群体
    - 议会
- answering
  - 没有带着问题阅读，纯属好奇
- questions
  - 没有问题
- reviews
  - 有人说中译本不好，最好直接看英文版《the crowd》
  - 本书可以对比《思考，快与慢》一起来看




## 3. 2010.10 | Machine Learning in Action

- reason

  - 之前就看过这本书，印象不错，现在想花点时间深入掌握机器学习相关的知识，就准备以本书为主，边看边查边练的方法来深入学习。

- what

  - 原理+代码来讲，可以中英文对照起看，遇到讲解不清楚，不完整的部分直接google，或者看其他书的相关章节，github上找了一个不错的 repo 来做练习，效果不错：https://github.com/litaotao/MachineLearning

- answering

  - 嗯，解答了不少知识点，最大的体会是只有实践了才知道自己究竟知道多少，理解多深

- question

  - 暂无

- reviews

  - 豆瓣评分 8.4，还行，毕竟没有完美的书，只有善用利用书本的人啦。不过可以吸取一些建议，比如后期遇到问题时可以参考周志华的《机器学习》和李航的《统计学习方法》来互补下。

  - 工程其实最重要的是实践，再简单的理论也能通过实践挖掘很多隐藏的知识点和细节问题，所以可以尝试找一些 kaggle 比赛的公开算法来练习练习。

  - 机器学习的东西可深可浅，知识点比较多，自己做了个简单的脑图来辅助总结：https://www.processon.com/diagraming/598bc11de4b02e9a26ee957c

    ​



## 4. 2010.10 | Docker - 从入门到实践

- reason

  - docker 这个技术是个好东西，以后必然有用到的地方
  - 初期准备基于 docker + tensorflow 来搭建深度学习平台，如此更应该认真的了解 docker 了

- what

  - Docker 简介

    > docker 使用 go 语言开发，基于 linux 内核的 cgroup，namespace，aufs，unionfs 等技术对进程举行封装隔离，属于 ***操作系统层面的虚拟化技术***。 由于隔离的进程独立于宿主和其他隔离的进程，因此也称为***容器***， 最初基于 lxc，后来使用自行开发的 libcontainer，后来演化为 runc 和 containerd。
    >
    > docker 与传统虚拟化区别：
    >
    > - 传统虚拟机是先虚拟出一套硬件，再到上面运行一套完整的操作系统，再到该系统上运行应用程序；
    > - docker 是应用程序直接运行于宿主的内核，容器没有自己的内核，也没有硬件虚拟化，轻便快捷；
    >
    > 为什么要使用 docker：
    >
    > - 高效的利用系统资源；
    > - 快速的启动时间；
    > - 一致的运行环境；
    > - 持续交付和部署；
    > - 轻松迁移，维护，扩展；

  - 基本概念

    > image 镜像：相当于一个 root 文件系统，提供了容器运行时所需要的程序，库，资源，配置等，不包括任何动态数据，其内容在构建之后也不会被改变。使用分层存储的架构。
    >
    > container 容器：镜像和容器的关系，类似于程序设计中 ***类*** 和 ***实例*** 的关系，镜像是静态的定义，容器是运行时的实体，容器可以被创建，启动，停止，删除，暂停等。容器的实质是进程，运行于属于自己的命名空间，有自己的 root 文件系统，网络配置等，运气起来类似于一个独立于宿主系统的操作系统一样。
    >
    > 镜像是用分层存储，容器也是如此。每一个容器运行时，是以镜像为基础，在其上面创建一个当期容器的存储层，我们可以称这个容器运行时为读写准备的存储层为 ***容器储存层***。容器储存层的生命周期同容器是一样的，所以 docker 的最佳实践是容器不应该向其储存层写入任何数据，容器储存层要保证物状态化，所有的文件写入操作，都应该使用 ***数据卷 volume***，或者绑定宿主目录，在这些位置写的时候回直接跳过容器储存层。且数据卷的生命周期独立于容器的，可以保证数据不会随着容器关掉而丢失。
    >
    > registry 仓库：集中存储，分发镜像的服务。一个镜像的唯一性标志：`<仓库名>:<标签>`。

  - 使用镜像

    > docker 运行容器前需要本地存在对应的镜像，如果镜像不在本地，就会从镜像仓库下载。
    >
    > 获取镜像：`docker pull [选项] [docker registry 地址]<仓库名>:<标签>`， registry 地址一般是 `<域名/ip>[: 端口号]`，默认是 docker hub；仓库名是两段式名称，一般是 `<用户名>/<软件名>`，对于 docker hub，如果不给出用户名，则默认为 library，也就是官方镜像。
    >
    > 运行镜像：`docker run -it --rm ubuntu:14.04 bash`，docker run 就是运行容器的明亮，-it 只打开一个交互式终端；`--rm` 说容器退出后将其删除；`bash`放在镜像名字后的是命令，这里我们希望有一个交互式的 shell，所以用 bash。最后可以通过 exit 退出这个容器。

  - 列出镜像

    > 可以使用 docker images 来列出已经下载下来的镜像；
    >
    > docker images 中的镜像体积总和并非是所有镜像实际硬盘消耗的大小，由于 docker 镜像是多层存储结构，并且可以继承，复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 docker 使用 union fs，相同的层只需要保存一份即可，因此实际镜像硬盘所占空间很可能比这个列表镜像大小的总和要小得很多。
    >
    > ***虚悬镜像***: 既没有仓库名也没有标签的镜像称为虚悬镜像，docker pull 和 docker build 都可能导致这种现象发生，一般是因为老的镜像被❤新的镜像覆盖掉。
    >
    > ```shell
    > taotao@mac007:~/google_driver/github/litaotao.github.io$docker images
    > REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
    > <none>                  <none>              de46bac71bad        2 hours ago         1.24GB
    > <none>                  <none>              96fab440b087        2 hours ago         1.24GB
    > <none>                  <none>              88cd00044d2b        2 hours ago         1.24GB
    > <none>                  <none>              f0abe216fb71        2 hours ago         1.24GB
    > <none>                  <none>              707a4e62e6ed        2 hours ago         1.24GB
    > <none>                  <none>              b22f3f2d3fa6        2 hours ago         1.24GB
    > tf/tf                   latest              bcf2d3d815e1        2 hours ago         1.24GB
    > ```
    >
    > 这类镜像可以直接删掉，没有任何价值：`docker rmi $(docker images -q -f dangling=true)`。
    >
    > ***中间层镜像***： docker images -a 可以查看所有镜像，包括中间层镜像，docker images 只显示顶层镜像。中间层镜像即构建顶级镜像中间过程中会用到的镜像。
    >
    > ***镜像筛选***： `docker images <仓库名>:<标签>` 来筛选镜像。

  - 利用 commit 理解镜像构成

    > `docker run --name webserver -d -p 80:80 nginx` 这条命令使用 nginx 镜像启动了一个容器，命名为 webserver，并且映射了 80 端口。如果修改了容器内部的内容，可以通过 `docker diff <容器名>` 来查看具体的改动。当我们运行一个容器的时候，我们做的任何文件修改都会被记录在容器存储层（没有特定写在数据卷或宿主机的时候），此时可以使用 docker commit 来将容器存储层的数据保存下来成为新的镜像。格式为：`docker commit [options] <container id> [<repo name>:<tag>]`。这里和 git 版本控制很想。commit 后可以通过 docker images 看到新生成的镜像。还可以使用 docker history 查看具体镜像的修改记录。`docker history <repo name>:<tag>`。

  - 使用 Dockerfile 来定制镜像

    >dockerfile 是一个文本文件，包含了一条条 ***指令***，每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建。
    >
    >- 核心
    >  - `FROM 基础镜像`，每一个镜像都是从一个基础镜像来就行修改定制的，在一个 dockerfile 文件中，from 是必备的，且必须是第一条指令。
    >  - `RUN 命令` 第二个核心的 run 命令，有两种格式。第一种是 shell 模型，即 `run <shell command>`，第二种是 exec 格式的，即 `run [可执行文件，参数1，参数2]`，类似于函数调用。
    >
    >之前说过，dockerfile 中每一个指令都会建立一层，命令的执行过程一般是：新建立一层，在其上执行相关命令，执行完成后 commit 这一层的修改，构成新镜像。而 union fs 是有最大层数限制的，比如 aufs 限制不超过 127 层。所以尽量把相关命令通过 `&&` 连接符连接起来运行。
    >
    >构建镜像通过命令 `docker build [options] <context/url/->` 。docker 运行时分为 docker engine （也就是服务端守护进程），和 docker client。docker engine 提供来一组 rest api，被称为 docker remote api，而 docker 命令这样的 client 则是通过这组 api 和 docker engine 进行交互的，从而完成各种功能。因此表面上看似我们在本机执行各种 docker 功能，实际上一切都是使用远程调用的形式在 docker engine 端完成，即 C/S 架构，这让我们操作远程 docker engine 变得轻而易举。然后当我们进行镜像构建的时候，并非所有的定制都通过 run 命令进行，经常需要将本地一些文件复制到镜像种，比如通过 copy，add 命令等。而 docker build 镜像时，其实并非在本地构建，而是在 engine 端，所以考虑如何让 engine 和一些本地文件进行交互的时候，就引入了 ***上下文*** 的概念，或者简单的说，上下文是指在构建镜像的时候，会将上下文路径下的所有内容打包上传给 engine 端，engine 收到这个上下文包后，展开就会获得构建镜像所需要的一切文件。

  - dockerfile指令详解

    > copy 复制文件：`copy <source> <destination>`，目标路径可以是容器内的绝对路径，也可以是相对于工作目录第相对路径，工作目录通过 `WORKDIR` 来制定。使用 copy 命令，源文件的各种元数据都会保留，比如读写执行权限，文件变更时间等。
    >
    > add 高级复制：add 语法同 copy，一般来说，所有的文件复制均使用 copy 指令，仅在需要自动解压的场合使用 add。
    >
    > cmd 容器启动命令：cmd 和 run 命令类似，也支持 shell 和 exec 两种格式。cmd 指令用于容器启动的时候制定运行的程序和参数。docker 不是虚拟机，容器中的应用都应该以前台运行，而不是像虚拟机，物理机那样用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。所以如果这样写 `cmd service nginx start` 的时候，会发现容器执行后就立即退出了。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义。而使用 `service nginx start`，会被docker解析成 `cmd service nginx start`, 然后解析成 `cmd ['sh', '-c', 'service nginx start']`，因此主进程实际上是 sh，那么当 service nginx start 结束后，sh 也就结束了，sh 作为主进程退出了，自然就会让容器也退出。正确的做法应该是直接执行 nginx 文件，并且要求其以前台形式运行，比如`cmd ["nginx", "-g", "daemon off"]`。
    >
    > ​
    >
    > entrypoint 入口点： 高级 cmd，以后用到的话再看。
    >
    > ​
    >
    > env设置环境变量	：两种格式：`env <key><value> or env <key>=<value> <key>=<value>`。
    >
    > ​
    >
    > arg 构建参数：格式：`arg <参数名>[=<默认值>]`。效果和 env 一样，都是设置环境变量值，所不同的是 arg 设置的是构建环境的环境变量，在将来容器运行时不会存在这些环境变量的。
    >
    > ​
    >
    > volume 定义匿名卷：格式为：`volume ["path1", "path2", ...] or volume <path>`。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 dockerfile 中我们可以实现制定某些目录挂载为匿名卷，这样运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器储存层写入大量数据。 
    >
    > ​
    >
    > expose 暴露端口：格式为：`expose <端口1>[<端口2, ...]`， expose声明容器提供服务的端口，在 dockerfile 中写入这个有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，另一个是在运行时使用随机端口映射时，也就是 `docker run -P` 时，会自动随机映射到 expose 暴露的端口。要将 expose 和运行时使用 `-P <宿主端口>:<容器端口>` 区分开来。`-p` 是映射宿主端口和容器端口，即将容器的对应端口服务公开给外界访问，而 expose 仅仅声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。
    >
    > ​
    >
    > workdir 指定工作目录：格式为：`workdir <工作目录路径>`。 
    >
    > ​
    >
    > user 指定当前用户：格式：`USER <用户名>`。 user 和 workdir 相似，都是改变环境状态并影响以后的层，workdir 改变工作目录，user 则改变之后层执行的 run，cmd 以及 entrypoint 这类命令的身份。
    >
    > ​
    >
    > healthcheck 健康检查：格式：`healthcheck [options] cmd <cmmand>`, 设置容器检查健康状况的命令； ` healthcheck none` 如果基础镜像有健康检查的指令，使用这行可以屏蔽掉其健康检查指令。
    >
    > ​
    >
    > onbuild 为他人做嫁衣：格式：`onbuild <other command>`， onbuild 是一个特殊的指令，他后面跟的其他指令，比如 run，copy 等，而这些指令在当前镜像构建时不会被执行，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。

  - 删除本地镜像：

    > `docker rmi [options] <image1> [<image2>, ...]`，其中 image 可以通过镜像 ID，镜像名或者镜像摘要来指定，  `docker rm`  是删除容器。一些高级用法：
    >
    > `docker rmi $(docker images -q -f dangling=true)` ，批量删除虚悬镜像；
    >
    > `docker rmi $(docker images -q redis)`，批量删除所有仓库名为 redis 的镜像；
    >
    > `docker rmi $(docker images -q -f before=mongo:3.2)`，批量删除所有在mongo:3.2 之前的镜像；

  - 镜像的实现原理

    > docker 的每个镜像都由很多层次构成，它使用 union fs 将这些不同的层结合到一个镜像中去。通常union fs 有两个用途，一方面可以实现不借助 lvm，raid 等将多个 disk 挂载到同一个目录下面，另一个更常用的是将一个只读的分支和一个可写的分支联合在一起。

  - 操作容器

    > ***启动***：有两种方式启动容器，一是基于镜像新建容器并启动，二是将终止状态的容器启动。主要命令就是 `docker run`。例如
    >
    > `docker run ubuntu:14.04 /bin/echo "hello world"` : 跟在本地执行 `/bin/echo "hello world"` 没啥区别；
    >
    > `docker run -it ubuntu:14.04 /bin/bash`：启动一个容器并打开一个 bash 终端，允许用户进行交互。其中 -t 是让 docker 分配一个伪终端并绑定到容器的标准输入上；-i 则是让容器的标准输入保持打开。
    >
    > 当利用 docker run 来创建容器时，docker 在后台运行的标准操作包括：
    >
    > - 检查本地是否存在指定的镜像，不存在就从公有仓库下载；
    > - 利用镜像创建并启动一个容器
    > - 分配一个文件系统，并且在只读的镜像层外面挂载一层可读写层
    > - 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；
    > - 从地址池配置一个 ip 地址给容器
    > - 执行用户指定的应用程序
    > - 执行完毕后容器被终止
    >
    > ***守护态运行***： 使用 -d 可以指定容器在后台运行，并可以使用 docker logs 查看容器的标准输出。
    >
    > ***终止容器***： 使用 docker stop 来终止一个运行中的容器。终止状态的容器可以使用 `docker ps -a` 来查看，处于终止状态的容器，可以通过 `docker start` 命令来重启。
    >
    > ***进入容器***： 使用 `-d` 参数使容器在后台运行时，可以通过 `docker attach` 或者 `nsenter` 工具来进入容器。但是使用 docker attach 有时候不方便，当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示，当某个窗口因命令阻塞时，其他窗口也就无法执行操作了。更好的方法是通过 `docker exec` 来进入容器。

  - 访问仓库

    > ***登陆***： 通过 docker login 来注册登录，注册完成后，本地家目录下的 `.dockercfg` 中会保存用户的认证信息；
    >
    > `docker search ` 可以用来查找官方镜像库；
    >
    > `docker pull` 可以用来下载镜像到本地；

  - 数据管理

    > ***数据卷***： 数据卷是一个可供一个或多个容器使用的特殊目录，类似于 linux 下对文件或者目录进行 mount，它绕过 ufs，可以提供很多有用的特性：
    >
    > - 数据卷可以在容器之间共享和重用；
    > - 对数据卷的修改立即生效；
    > - 对数据卷的更新不会影响镜像；
    > - 数据卷默认会一直存在，即使容器被删除；
    >
    > 通过 `-v` 来创建一个数据卷并挂载到容器里。`docker run -d -P --name web -v /webapp training/webapp python app.py` 里面就创建了一个数据卷到容器的 webapp 目录，也可以在 dockerfile 中通过关键字 volume 来添加一个或多个新的卷到由该镜像创建的任意容器。
    >
    > 数据卷是用来持久化数据的，它的生命周期独立于容器。如果在删除容器的同时要移除数据卷，可以在删除容器的时候使用 `docker rm -v` 这个命令。
    >
    > `docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py`  可以加载主机的 `src/webapp` 目录到容器中的 `/opt/webapp` 目录，这样即可挂载一个主机目录作为数据卷。dockerfile 中不支持这种用法，因为 dockerfile 是为了抑制和分享用的，然后不同的操作系统路径格式不一样，所以目前还不支持。
    >
    > 在主机中可以使用 `docker inspect` 来查看容器详细信息。
    >
    > ​
    >
    > ***数据卷容器***： 如果有一些持续更新的数据需要在不同容器之间共享，可以创建数据卷容器，其实就是一个正常的容器，专门用来提供数据卷给其他容器挂载。两步走：
    >
    > - `docker run -d -v /dbdata --name dbdata training/postgres` 创建一个数据卷容器
    > - `docker run -d --volumes-from dbdata --name db1 training/postgres` 在其他容器中使用 `--volumes-from` 来挂载 dbdata 容器中的数据卷。

  - 使用网络

    > ***外部访问容器***： 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 `-P, -p` 来制定端口映射。当使用 `-P` 时，docker 会随机映射一个 49000～49900 的端口到内部容器开放的网络端口。使用 `-p` 时可以制定要映射的端口，并且在一个指定端口上可以只绑定一个容器，支持的格式有：`ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort`。后面可以使用 `docker port` 来查看当前映射的端口配置。
    >
    > ***容器互联***： 容器的连接 linking 系统是除了端口映射外，另一种跟容器中应用交互的方式，该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。

  - 高级网络配置

    > 略

  - 安全

    > 略

  - 底层实现

    > docker 底层的核心包括 linux 上的命名空间 namespaces，控制组 control groups，union 文件系统 和 容器格式 container format。
    >
    > ***基本架构***： docker 采用了 c/s 架构，docker daemon 作为服务端接受来自客户端的请求，并处理这些请求。客户端和服务端既可以运行在一个机器上，也可以通过 socket 或者 restful api 来进行通信。
    >
    > ![图片注释](http://odqb0lggi.bkt.clouddn.com/5480622df9f06c8e773366f4/2cb2257a-b56f-11e7-95fa-0242ac140002)
    >
    > ***命名空间***： 每个容器都有自己的命名空间，运行在其中的应用都像是在独立的操作系统中一样，命名空间保证了容器之间彼此互不影响。比如说有 pid 命名空间，net 命名空间，ipc 命名空间，mnt，uts，user 命名空间。
    >
    > ***控制组***： cgroups 是linux内核的一个特性，主要用来对共享资源进行隔离，限制，审计等，只有能控制分配到容器的资源，才能避免当多个容器同时运行时对系统资源的竞争。它可以对容器的内存，cpu，磁盘io等资源进行限制和审计。
    >
    > ***联合文件系统***： unionfs是一种分层，轻量级并且高性能的文件系统，他支持对文件系统的修改按照一层一层来叠加。
    >
    > ***容器格式***：最初采用 lxc 中的容器格式，后来发展为 libcontainer，现在应该是演化为 runc 和 containerd。
    >
    > ***网络***：docker 的网络实现骑士就是利用了 linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。


- answering
  - 无问题阅读，纯学习
- questions
  - 无
- reviews
  - 无











# 高质量文章

## 1. 2010.10 | 30条社会扎心潜规则，你看懂了几条？

> 能在一定位置上的人，一定有他的过人之处，不管你多么讨厌他。
>
> 要想屏蔽某些人的朋友圈，最好把同事微信分到一个组里，要屏蔽一起都屏蔽了。
>
> 不要总在旁人面前提你的朋友多牛逼，你要懂得，别人的成就与你无关。
>
> 朋友同事之间，帮忙是情分，不帮忙是本分，不要把别人对你的好，当作理所当然。
>
> 和同事拼单买东西叫外卖，一定把支付明细的截图发给每个人，你信任我，当然我也靠得住。
>
> 借了别人的钱一定要按时还，如果一次还不了就分多次，如果没钱就多联系对方，千万别因愧疚而不理对方，很容易被理解为心安理得不闻不问。
>
> 不要轻易把心底深处不愿示人的部分坦露出来，靠同情轻易获得的朋友，内心不一定看得起你。
>
> 不管学校，职场或社会，都不要违背心意地一味讨好别人，有些圈子终究不属于自己，努力做好自己，讨好自己可能会更容易有丰厚回报。
>
> 不要总是反驳别人，更不要总在他人面前抱怨。抱怨不但解决不了问题，还会一次次地强化顽固思维，本来没多大的事儿说多了就更让自己生气，最终陷入全世界都亏欠自己的怪圈。
>
> 我们总是喜欢拿顺其自然来敷衍人生道路上的荆棘坎坷，却很少承认，真正的顺其自然，其实是竭尽所能之后的不强求，而非两手一摊的不作为。
>
> 别随性地把兴趣变成职业。
>
> 不管你是想去创业，还是想去流浪，如果你一直犹豫且小心翼翼，那是因为你还没有试错的成本。一旦决定了一件事就要踏实去做，别一鼓作气再而衰三而竭。
>
> 收到回复是一种尊重，是人品的体现。
>
> 别人给你看手机里的照片，请不要顺手左右划着看，别人东西不要随便乱动，想用先征询一下别人的意见，如果借给了你定要好好爱惜。
>
> 不要隔着屏幕就去诋毁一件事或是一个人，你所看到的，只是别人希望你看到的。事情的真相，只有当事人清楚。
>
> 人生苦短，你要把善意、耐心、尊重、宽容用在那些值得你这样对待的人身上，有些人，不值得。
>
> 工作后，你的交际圈会越来越小，很难认识新的朋友，那种没有任何功利性的朋友更是难得。
>
> 当你辉煌时，身边总是不缺朋友，而当你窘迫时，朋友却都散开了。真正的朋友是什么样子？大概就是：我成功，他不嫉妒；我萎靡，他不轻视。
>
> 真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。凡事适度即可，太用力的人跑不远，太用力的爱不圆满。
>
> 看破不说破，知人不评人，知理不争论。
>
> 沉不下心看书，浮躁和焦虑，都是因为年纪渐长，不信正道而太重功利导致的。
>
> 学会存钱，克制欲望，你永远不知道什么时候要用到钱。
>
> 身体是革命的本钱。一个很差的身体带给你的局限不可能靠意志力突破。
>
> 我从来不相信什么懒洋洋的自由，我向往的自由是通过勤奋和努力实现的更广阔的人生，那样的自由才是珍贵的、有价值的；我相信一万小时定律，我从来不相信天上掉馅饼的灵感和坐等的成就。做一个自由又自律的人，靠势必实现的决心认真地活着。
>
> 便宜的东西，只有你买的那一刻是开心的，用的时候没有一天是开心的，品质好的东西，给钱那一刻是心疼的，用的时候每天都是快乐的，感觉特别值得。
>
> 我犯的最大的错误，就是我以为往下走工作比较轻松，实际上往上走反而比较轻松，因为层次高的人脑子比较清楚，做事讲道理。小地方很多人脑子转不开，你每天去跟他们吵吵，时间精力都浪费在这上面了。找对象也是一样，你以为你找一个老实的，单纯的，好过日子，实际上他脑子要是不好，更麻烦。
>
> 麦兜说：有事情是要说出来的，不要等着对方去领悟，因为对方不是你，不知道你想要什么，等到最后只能是伤心和失望，尤其是感情。
>
> 不要对一个人太好，因为你终会发现，这样时间久了，那个人是会习惯的，然后把你做的一切看作是理所应当。其实本来是可以蠢到不计代价不顾回报的，但现实总是让人寒了心。其实你明明知道，最卑贱不过感情，最凉不过是人心。
>
> 这个社会很现实：久病床前无孝子，久贫家中无贤妻。有钱走遍天下，无钱寸步难行。
>
> 人的天性本就凉薄，只要拿更好的来换，一定会舍得。



## 2. 2010.10 | 深度好文：阶级竞争即将由抢房，升级为抢

>**我们应该积极的思考：阶级竞争的本质是什么，终局是什么，下一步如何布局？**
>
>在中国，阶级竞争的焦点不会在房产停留太久，会很快向前切换，不断升级演变：
>
>1. 开局是地产（静态博弈，一劳永逸）；
>2. 中场是教育（动态博弈，价值提升）；
>3. 终局是时间（全局博弈，拿钱买命）。
>
>重视教育并不是亚洲家长的偏执，而是社会发展的必然：
>
>1. **高薪工作所需的技能和知识壁垒在不断加高**
>2. **技术的进步在加速阶层的洗牌和分化，高知阶层碾压底层是常态**
>3. **保持足够强的学习能力是保持在本阶层的关键。**
>
>**智商税是这个地球上最重的赋税。**

## 3. 2010.10 | 分分钟读懂私募股权投资“募、投、管、退”全流程！

> GP: 普通合伙人，有限合伙制基金中承担基金管理人角色的投资管理机构。
>
> LP: 有限合伙人，有限合伙制基金中的投资者。
>
> **天使投资：**是权益资本投资的一种形式，指富有的个人出资协助具有专门技术或独特概念的原创项目或小型初创企业，进行一次性的前期投资。
>
> **VC（VentureCapital,风险投资）：******由风险投资机构投入到新兴的、迅速发展的、具有巨大竞争潜力的企业中的一种权益资本，即对成长期企业的投资。
>
> **PE（PrivateEquity,私募股权投资）：******与上述VC的定义对比来讲，此处指狭义的私募股权投资。狭义的PE主要指对已经形成一定规模的，并产生稳定现金流的成熟企业的私募股权投资。而广义的PE指涵盖企业首次公开发行前各阶段的权益投资，即处于种子期、初创期、发展期、扩展期、成熟期和Pre-IPO各个时期企业所进行的投资。主要可以分为三种：PE-Growth：投资扩张期及成熟期企业；PE-PIPE：投资已上市企业；PE-Buyout：企业并购，欧美许多著名私募股权基金公司主要业务。
>
> **PE FOFs：******私募股权母基金。
>
> **承诺出资制：******承诺出资是有限合伙形式基金的特点之一，在资金筹集的过程中，普通合伙人会要求首次成立时一定比例的投资本金到位，而在后续的基金运作中，投资管理人根据项目进度的需要，以电话或者其他形式通知有限合伙人认缴剩余部分本金。
>
> **优先收益：******又称“门槛收益率”，优先收益条款确保了一般合伙人只有在基金投资表现优良之时才能从投资收益中获取一定比例的回报。
>
> **IPO（InitialPublic Offerings,首次公开募股）**
>
> **并购：******一般指兼并和收购。
>
> **尽职调查：******在基金或公司层面对私募股权进行成功投资需要事先详尽的调查。要进行长期投资，有必要在签约前审核分析交易牵涉的所有因素。尽职调查要全面审核许多因素，比如管理团队的能力、公司业绩、交易状况、投资战略、合法证券等等。
>
> **关键人条款：******由于私募股权基金投资风险较大，基金管理人的能力对于基金整体业绩的影响较大，因而基金条款中会有关键人条款，即基金团队中指定的核心成员在整个基金存续期间不得离开，否则投资人有权要求召开合伙人会议，提前对基金进行清算。
>
> **联合投资：******对于一个投资项目，可能会有多个机构同时关注。
>
> **过桥融资贷款************（Bridgefinancing）：******公司在正式IPO或私募融资前为确保经营和融资活动顺利推进所进行的短期贷款，通常期限在1年以内，最终会被永久性的资本如股权投资者或长期债务人所取代。
>
> PE基金的运作流程可以细分为四个环节：募资、投资、管理、退出。
>
> ![](https://mmbiz.qpic.cn/mmbiz_jpg/TF5yroGAEibbcHZa76YTry2tAEFCW2gV9MkA7tE6RFYlEjFaRVkicpkYES2wZsiblEO9y5EXeWGInXvMS5XevZNGw/640)



## 4. 2010.10 | Lambda架构实践-打造高并发实时计量的智能数据商场

> ![](https://mmbiz.qpic.cn/mmbiz_png/8biaFoWLFLS0gKiaKXQjmF1VTDOMDeOia16yic8vic6wTJZMq3t3wPh93qibKWzoozXibrO5PbR9JneJXat61ic9ibXwCAw/640)
>
> 这是一个典型的 Lambda 架构系统。对用量的计算分为两个部分，批处理部分（批处理层）和实时流处理部分（速度层），最后由查询服务（服务层）聚合批处理层和快速层的数据提供查询服务。
>
> - lambda 架构
>   - 用函数式编程的观点来设计系统架构，在宏观层面上享受了一些函数式编程的优势
>   - 大数据处理技术需要解决这种可伸缩性与复杂性。首先要认识到这种分布式的本质，要很好地处理分区与复制，不会导致错误分区引起查询失败，而是要将这些逻辑内化到数据库中。当需要扩展系统时，可以非常方便地增加节点，系统也能够针对新节点进行rebalance。其次是要让数据成为不可变的。原始数据永远都不能被修改，这样即使犯了错误，写了错误数据，原来好的数据并不会受到破坏。
>   - Storm的作者NathanMarz提出的一个实时大数据处理框架（Lambda架构）就满足以上两点。Marz在Twitter工作期间开发了著名的实时大数据处理框架Storm，Lambda架构是其根据多年进行分布式大数据系统的经验总结提炼而成。
>   - Lambda架构的目标是设计出一个能满足实时大数据系统关键特性的架构，包括有：高容错、低延时和可扩展等。Lambda架构整合离线计算和实时计算，融合不可变性（Immunability），读写分离和复杂性隔离等一系列架构原则，可集成Hadoop，Kafka，Storm，Spark，Hbase等各类大数据组件。









- ​
- ​
- [一直以来伴随我的一些学习习惯(三)：阅读方法]([http://mindhacks.cn/2008/09/17/learning-habits-part3/)
- ​